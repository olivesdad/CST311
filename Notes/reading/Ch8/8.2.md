# 8.2 Cryptography
### Acronymns
- [[DES]]
- [[3DES]]
- [[AES]]
- [[NIST]]
- [[(XOR)]]

## Symmetric Key Cryptography
- Very old form of cryptography (Ceasar cipher) 
	- Taking each letter in plaintext message and incrementing it by **K** letters
- MOnoalphateic cipher is lining up each letter with a different letter and needing the mapping to decipher the message 
##### Breaking the code
- Ciphertext-only: Maybe this is brute force
- Known-plaintext attack: an attacker knows some words in the text and can decode part of the letters by that knowledge
- Chosen-painttext attack: somehow the attacker is able to get a known message encrypted 

### Block Ciphers (Includes DES)
Modern symmetric key encryption.  include
- Used in PGP, SSL, IPsec
-  Message to be encrypted is processed in blocks of *K* bits
	- if bit string is broken up into blocks of 3 bits then each block would map to a different block of 3 bits like 000 -> 101, 001 -> 111, etc...
- Possible combination are permutation of block size so if there are in this case 8 possible 3 bit inputs  and those same 8 3 bit outputs then there are **8!=40,320** possible permutations 
> the number of possible mappings for a general k-block cipher is $2^k!$
 
![[Pasted image 20220518223858.png]]
In the above example, instead of having a a cipher table for 64 bit long bit strings, there are 8 tables of 8bit ciphers and a scrambler function and this process is repeated **`n`** times

### some shitty example 
Sender has the followingn algorithm
- $c(i)=K_S(m(i)⊕r(i))$

 >[!variables] 
 >m(i) = plain text block
 > c(i) = ciphertext block
 > r(i) = some random number k-bit number
 > $K_s$= Block-cipher encryption algorithm This is just a map not multiplication
-  sender send c(i) and r(i) so reciever and reciever inorder to get m(i) does
	- $m(i) = K_s(c(i))⊕r(i)$ `<- Notice the order of the encryption has changed. You first perform the decryption on the cipher text then XOR it with the random number`
- When you perform the XOR again you get back the Mi 

# Public Key Encryption
### Diffie-Hellman Key Exchange
 - Consists of 2 keys
	 - public key KB+
	 - private key KB-
 - Sender has the KB+ from reciever and uses that key to encrypt data before sending it
 - Reciever decrypts the message with know algorithm (like RSA) using their private key
### [[RSA]]

 - Uses modulo arithmatic
 - Synonymous with public key cryptography
 - $(a \% n)^d\%n=a^d\%n$ <- This identiy is why `wtf algo` works
 - This process is rather time consuming so maybe use [[RSA Fast]]
>[!WTF Algorithm]
>- User does some stuff with prime numbers and factoring to select key pairs
>- 2 pairs consist of  (*d* stands for decrypt *e* stands for encrypty)
>	- pub (n,e) 
>	- private (n,d)
>- Encryption $m^e \% n=c$ 
>- Decryption $c^d \% n=m$
 ---
- RSA is secure because in order to get the d number you would have find factors of n and test them or soemthing. Whatever you ahve to do is difficult because there is no known algorithm to easily factor large numbers